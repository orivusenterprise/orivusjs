#!/usr/bin/env node
/**
 * OrivusJS E2E Test Command
 * 
 * Tests the entire generation pipeline for a product.
 * 
 * Usage: npm run orivus:e2e-test specs/products/blog
 */

import fs from "fs";
import path from "path";
import { execSync } from "child_process";
import { ModuleSpec } from "../core/module-spec";
import { validateSpec, formatValidationResult } from "../core/spec-validator";

// ============================================================================
// Types
// ============================================================================

interface ProductManifest {
    name: string;
    description: string;
    version: string;
    modules?: Array<{ file: string; order: number }>;
    executionOrder?: string[];
    relations?: {
        graph: Record<string, string[]>;
    };
}

interface E2EResult {
    success: boolean;
    product: string;
    modulesGenerated: number;
    testsPassed: number;
    totalTests: number;
    duration: number;
    errors: string[];
}

// ============================================================================
// Helpers
// ============================================================================

function log(emoji: string, message: string): void {
    console.log(`${emoji}  ${message}`);
}

function runCommand(command: string, cwd: string): { success: boolean; output: string } {
    try {
        const output = execSync(command, {
            cwd,
            encoding: "utf-8",
            stdio: ["pipe", "pipe", "pipe"]
        });
        return { success: true, output };
    } catch (error: any) {
        return {
            success: false,
            output: error.stdout?.toString() || error.stderr?.toString() || error.message
        };
    }
}

function cleanGeneratedFiles(projectRoot: string): void {
    const domainPath = path.join(projectRoot, "src/domain");
    const appPath = path.join(projectRoot, "src/app");

    // Clean domain folders (but not the domain folder itself)
    if (fs.existsSync(domainPath)) {
        fs.readdirSync(domainPath).forEach(folder => {
            const folderPath = path.join(domainPath, folder);
            if (fs.statSync(folderPath).isDirectory()) {
                fs.rmSync(folderPath, { recursive: true });
            }
        });
    }

    // Clean app routes (keep api, docs, and core files)
    const keepFolders = ["api", "docs"];
    if (fs.existsSync(appPath)) {
        fs.readdirSync(appPath).forEach(item => {
            const itemPath = path.join(appPath, item);
            if (fs.statSync(itemPath).isDirectory() && !keepFolders.includes(item)) {
                fs.rmSync(itemPath, { recursive: true });
            }
        });
    }

    // Reset Prisma schema
    const prismaPath = path.join(projectRoot, "prisma/schema.prisma");
    const cleanSchema = `generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}
`;
    fs.writeFileSync(prismaPath, cleanSchema);

    // Reset router
    const routerPath = path.join(projectRoot, "src/server/trpc/index.ts");
    const cleanRouter = `// --------------------------------------------------------
// ü™Ñ AUTO-GENERATED BY ORIVUSJS
// --------------------------------------------------------
// Do not edit this file manually.
// It is automatically updated by the Orivus CLI.
// --------------------------------------------------------

import { router } from "./router";


export const appRouter = router({

});

export type AppRouter = typeof appRouter;
`;
    fs.writeFileSync(routerPath, cleanRouter);

    // Reset navigation
    const navPath = path.join(projectRoot, "src/config/navigation.ts");
    const cleanNav = `import { NavItem } from '@/types/nav';

export const navigation: NavItem[] = [
    { name: 'Dashboard', href: '/', icon: 'Home' },
    // ORIVUS_INJECTION_POINT
];
`;
    fs.writeFileSync(navPath, cleanNav);

    // Delete SQLite database
    const dbPath = path.join(projectRoot, "prisma/dev.db");
    if (fs.existsSync(dbPath)) {
        fs.unlinkSync(dbPath);
    }
}

// ============================================================================
// Main
// ============================================================================

async function main(): Promise<void> {
    const startTime = Date.now();
    const args = process.argv.slice(2);
    const productPath = args[0];

    if (!productPath) {
        console.log("‚ùå Please provide the path to a product folder.");
        console.log("Usage: npm run orivus:e2e-test <path-to-product>");
        console.log("Example: npm run orivus:e2e-test specs/products/blog");
        process.exit(1);
    }

    const projectRoot = process.cwd();
    const absoluteProductPath = path.isAbsolute(productPath)
        ? productPath
        : path.join(projectRoot, productPath);

    // Check if product folder exists
    if (!fs.existsSync(absoluteProductPath)) {
        console.error(`‚ùå Product folder not found: ${absoluteProductPath}`);
        process.exit(1);
    }

    // Check for manifest
    const manifestPath = path.join(absoluteProductPath, "_manifest.json");
    if (!fs.existsSync(manifestPath)) {
        console.error(`‚ùå No _manifest.json found in: ${absoluteProductPath}`);
        console.error("üí° Create a _manifest.json with the product configuration.");
        process.exit(1);
    }

    console.log("\n" + "=".repeat(60));
    console.log("üß™ ORIVUSJS E2E TEST");
    console.log("=".repeat(60));

    // Read manifest
    const manifest: ProductManifest = JSON.parse(fs.readFileSync(manifestPath, "utf-8"));

    // Get module files from executionOrder or modules array
    const moduleFiles: string[] = manifest.executionOrder
        || manifest.modules?.map(m => m.file)
        || [];

    log("üì¶", `Product: ${manifest.name} v${manifest.version}`);
    log("üìã", `Modules: ${moduleFiles.length} (${moduleFiles.join(", ")})`);

    const result: E2EResult = {
        success: false,
        product: manifest.name,
        modulesGenerated: 0,
        testsPassed: 0,
        totalTests: 0,
        duration: 0,
        errors: []
    };

    // =========================================================================
    // Step 1: Clean previous generation
    // =========================================================================
    console.log("\n" + "-".repeat(40));
    log("üßπ", "Cleaning previous generation...");
    cleanGeneratedFiles(projectRoot);
    log("‚úÖ", "Clean state ready");

    // =========================================================================
    // Step 2: Validate all specs
    // =========================================================================
    console.log("\n" + "-".repeat(40));
    log("üîç", "Validating all specs...");

    const specs: { name: string; path: string; spec: ModuleSpec }[] = [];
    let validationPassed = true;

    for (const moduleFile of moduleFiles) {
        const specPath = path.join(absoluteProductPath, moduleFile);
        const moduleName = moduleFile.replace('.json', '');

        if (!fs.existsSync(specPath)) {
            result.errors.push(`Spec file not found: ${moduleName}.json`);
            validationPassed = false;
            continue;
        }

        try {
            const spec: ModuleSpec = JSON.parse(fs.readFileSync(specPath, "utf-8"));
            const validation = validateSpec(spec);

            if (!validation.valid) {
                console.log(`\n‚ùå ${moduleName}:`);
                console.log(formatValidationResult(validation));
                result.errors.push(`Validation failed for ${moduleName}`);
                validationPassed = false;
            } else {
                log("‚úÖ", `${moduleName} - valid`);
                specs.push({ name: moduleName, path: specPath, spec });
            }
        } catch (error: any) {
            result.errors.push(`Failed to parse ${moduleName}: ${error.message}`);
            validationPassed = false;
        }
    }

    if (!validationPassed) {
        console.log("\n‚ùå Spec validation failed. Fix errors and try again.");
        result.duration = Date.now() - startTime;
        printResult(result);
        process.exit(1);
    }

    log("‚úÖ", `All ${specs.length} specs validated`);

    // =========================================================================
    // Step 3: Generate each module
    // =========================================================================
    console.log("\n" + "-".repeat(40));
    log("üî®", "Generating modules...");

    for (const { name, path: specPath } of specs) {
        log("‚è≥", `Generating ${name}...`);

        const genResult = runCommand(
            `npx tsx src/orivus/cli/create-module.ts ${specPath}`,
            projectRoot
        );

        if (!genResult.success) {
            result.errors.push(`Generation failed for ${name}: ${genResult.output}`);
            console.log(`‚ùå ${name} failed`);
            console.log(genResult.output);
            result.duration = Date.now() - startTime;
            printResult(result);
            process.exit(1);
        }

        result.modulesGenerated++;
        log("‚úÖ", `${name} generated`);
    }

    log("‚úÖ", `All ${result.modulesGenerated} modules generated`);

    // =========================================================================
    // Step 4: TypeScript check
    // =========================================================================
    console.log("\n" + "-".repeat(40));
    log("üìù", "Running TypeScript check...");

    const tscResult = runCommand("npx tsc --noEmit", projectRoot);
    if (!tscResult.success) {
        result.errors.push("TypeScript compilation failed");
        console.log("‚ùå TypeScript errors:");
        console.log(tscResult.output);
        result.duration = Date.now() - startTime;
        printResult(result);
        process.exit(1);
    }
    log("‚úÖ", "TypeScript check passed");

    // =========================================================================
    // Step 5: Run tests
    // =========================================================================
    console.log("\n" + "-".repeat(40));
    log("üß™", "Running tests...");

    const testResult = runCommand("npm run test -- --run", projectRoot);

    // Parse test results
    const passedMatch = testResult.output.match(/(\d+) passed/);
    const failedMatch = testResult.output.match(/(\d+) failed/);

    const passed = passedMatch ? parseInt(passedMatch[1]) : 0;
    const failed = failedMatch ? parseInt(failedMatch[1]) : 0;

    result.testsPassed = passed;
    result.totalTests = passed + failed;

    if (failed > 0 || !testResult.success) {
        result.errors.push(`${failed} tests failed`);
        console.log("‚ùå Some tests failed:");
        console.log(testResult.output);
        result.duration = Date.now() - startTime;
        printResult(result);
        process.exit(1);
    }

    log("‚úÖ", `All tests passed (${passed}/${result.totalTests})`);

    // =========================================================================
    // Success!
    // =========================================================================
    result.success = true;
    result.duration = Date.now() - startTime;

    console.log("\n" + "=".repeat(60));
    printResult(result);
    console.log("=".repeat(60));
}

function printResult(result: E2EResult): void {
    const status = result.success ? "‚úÖ PASSED" : "‚ùå FAILED";
    const durationSec = (result.duration / 1000).toFixed(2);

    console.log(`\n${status}: ${result.product}`);
    console.log(`   Modules: ${result.modulesGenerated}`);
    console.log(`   Tests: ${result.testsPassed}/${result.totalTests}`);
    console.log(`   Duration: ${durationSec}s`);

    if (result.errors.length > 0) {
        console.log(`   Errors:`);
        result.errors.forEach(e => console.log(`     - ${e}`));
    }
}

main().catch(error => {
    console.error("‚ùå Unexpected error:", error.message);
    process.exit(1);
});
